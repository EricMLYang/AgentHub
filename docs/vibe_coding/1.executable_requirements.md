---
name: 如何持續產生任務，保持 AI Coding 流程的運轉
description: 對於如何持續產生任務，保持 AI Coding 流程的運轉研究筆記
---

# 可執行的需求定義
可執行的需求定義：在把任務交給AI前，先確保需求拆解明確、具體且可驗證。換言之，每張交給AI的需求卡或Issue都應該包含明確的問題描述、範圍界定和驗收標準。避免模糊詞語和省略背景。例如不要僅寫“提升性能”，而是寫“將報表生成時間從5秒降到2秒，Acceptance: 在10000筆資料測試下達成”。系統思考：明確的輸入有助於AI輸出可預期結果，減少反覆試錯。本質上是將需求不確定性這個潛在干擾從迴路中剔除。


## 可執行的需求定義（Executable Requirements）
### 典型負責角色（誰的任務）
1. 主責（Owner）
* Product Manager / Product Owner（PO）：定義商業目標、範圍、驗收標準，決定「做/不做」。
* Tech Lead / Architect：把需求轉成可落地的技術切割與設計約束（風險、相依、可回滾）。

2. 共同參與（Co-author）
* Senior Engineer / Staff Engineer：補上 edge cases、非功能需求（效能/可靠性/成本）、可測性。
* QA / Test Engineer（若有）：把驗收條件轉成可測試的情境與案例，避免「主觀驗收」。

3. 被諮詢（Consulted）
* Designer / UX：當需求牽涉流程、互動或可用性。
* SRE / Platform：當需求牽涉部署、可靠性、監控、SLO。

### 一般開發者要怎麼精通
你要把自己練成「能把模糊問題變成可交付任務」的人。最有效的練法是：把需求寫到可以直接生成測試。

必練 5 個技能：

1. 把需求翻譯成可觀測結果
* 不是「改善效能」，而是「P95 從 5s → 2s」或「CPU < 60%」
* 練法：每次接到需求，先問自己「我用哪個指標證明它變好？」

2. 定義 DoD（Definition of Done）
* 功能完成 ≠ 可上線
* DoD 至少包含：測試、文件、監控、回滾/feature flag（視風險）

3.邊界條件與反例（Negative cases）
* 你能寫出 3 個「會失敗的情境」，代表你真的懂需求
* 練法：每張 issue 強迫自己寫「不應該發生什麼」

4. 切割成可獨立交付的最小單元
* 一個 PR 一個主題、可回滾、可測試
* 練法：你自己把大需求拆成 3–7 張小卡，每張都有驗收

5. 規格寫作能力（清楚、無歧義、可追溯）

* 練法：用固定模板寫 20 次，你會越寫越快（而且 AI 會越跑越順）

6. 最實用的個人訓練法（1 個月內很有感）：
你每週挑 1 個需求，你自己先寫一張「交給 AI 的規格卡」（含 acceptance + test hints），再看 PR 被退回的原因。
把退回原因分類：缺範圍？缺驗收？缺邊界？缺相依？缺非功能？
兩週後你就知道你真正薄弱的點。

## 工具 - OpenSpec
[OpenSpec 讓 SDD 變簡單的三個指令](https://kaochenlong.com/openspec)
[OpenSpec GitHub](https://github.com/Fission-AI/OpenSpec)


## 上游的需求具體化過程
以資深軟體開發 PM 的角度，幫我判斷以下事情怎麼做比較有效益:

期望:  透過 Coding Agent (github copilot, claude code ... )，搭配一個充滿上下文資訊的 Repo. ，可以持續的協助產出可被執行、符合方向的好需求文件，這些文件，後續會被其他流程轉成 spec，因此這裡只需要關注文件是否夠清楚，

痛點：平常在 PPT 整理報告，跟合作單位用會議溝通，實際要執行時，要寫在 Click UP 上，加上很多狀況是 PM 自己要依據產品方向想功能跟任務，加上大家都用 Coding Agent，因此開發加速後，這一段需求構想常常會是瓶頸

其他補充: 
請專注在更上游的需求來源， 我希望有一個 PM Agent (用現成 Coding Agent ) 能夠在充滿業務資訊、產品資訊、User 反饋和需求、利害關係人的 Repo.裡， 持續將比較抽象的內容，整理成需求文件，過程中因該會有 UIUX 設計師的知識、軟體工程和架構上的判斷，最終讓文件可以給下一階段 Agent 開 Spec， 幫我構想規畫這樣情境有人做過嗎? 大方向上怎麼做比較好?

以小團隊(6-10)可以運作為主，儘量輕便快速


### **核心策略：Knowledge-as-Code + Template-Driven Agent**

#### **一、Repo 結構設計（這是關鍵）**

```
product-requirements-repo/
├── /context/                    # 上下文知識庫
│   ├── business/               # 業務邏輯、商業模式
│   ├── product/                # 產品願景、roadmap、策略
│   ├── users/                  # User personas, feedback, interview notes
│   ├── stakeholders/           # 利害關係人需求、constraints
│   ├── tech-constraints/       # 技術限制、架構決策記錄(ADR)
│   └── design-system/          # UI/UX guidelines, design principles
│
├── /templates/                 # 需求文件模板
│   ├── feature-brief.md        # 功能簡述模板
│   ├── user-story.md           # User Story 模板
│   ├── technical-requirement.md
│   └── decision-log.md         # 決策記錄模板
│
├── /requirements/              # 輸出的需求文件
│   ├── /drafts/               # Agent 生成的草稿
│   └── /reviewed/             # PM review 後的版本
│
├── /prompts/                   # Agent 的 system prompts
│   ├── pm-agent-prompt.md     # PM Agent 的角色定義
│   ├── ux-reviewer-prompt.md  # UX 審查者角色
│   └── tech-reviewer-prompt.md
│
└── .cursorrules / .github/copilot-instructions.md
```

#### **二、已驗證的實踐案例參考**

**類似做法的公司/團隊：**
1. **Linear** - 他們內部用 AI 將 Slack討論/客戶反饋 → 結構化 Issue
2. **Glean** - Knowledge-grounded AI，類似你要的「在充滿上下文的 Repo 裡工作」
3. **開源案例：**
   - **PRD.ai** (GitHub: wandb/prd) - Weights & Biases 的 PRD generation tool
   - **Spec-first** approach with AI (Cursor + Anthropic 有團隊分享)

#### **三、具體實施方案（小團隊適用）**

##### **Phase 1: 建立知識基礎（2週）**

```markdown
**做法：**
1. 將現有 PPT、會議記錄、ClickUp → 轉成 Markdown 放入 /context
2. 建立 5-7 個核心模板（feature-brief, user-story, tech-requirement）
3. 寫一個 `.cursorrules` 或 `copilot-instructions.md`：

---
You are a Senior PM Agent specializing in [你的產品領域].

**Context Sources:**
- Business logic: /context/business/
- Product strategy: /context/product/
- User insights: /context/users/

**Your Task:**
When I provide abstract input (meeting notes, stakeholder request, idea),
you should:
1. Cross-reference /context to understand constraints
2. Apply UX heuristics (usability, accessibility)
3. Consider technical feasibility from /context/tech-constraints
4. Generate structured requirement using /templates/[appropriate-template].md

**Quality Checklist:**
- [ ] Clear user value proposition
- [ ] Measurable success criteria
- [ ] Technical implementation hints
- [ ] Edge cases considered
- [ ] Linked to product strategy
---
```

##### **Phase 2: Agent Workflow（邊做邊優化）**

**A. 輸入來源處理：**
```bash
# 會議後，直接跟 Agent 對話
"今天會議討論要加入 [功能X]，主要是利害關係人Y的需求，
請參考 /context/stakeholders/Y.md 和 /context/product/roadmap-Q1.md，
生成一個 feature brief"
```

**B. Multi-pass Review（用不同 Agent persona）：**
```bash
# Pass 1: PM Agent 生成初稿
# Pass 2: 切換成 UX Reviewer persona review
# Pass 3: Tech Reviewer persona 檢查可行性
# Pass 4: PM 人工 final review
```

##### **Phase 3: 串接下游（1-2週後）**

```
Requirements Repo → (GitHub Action / Make.com) 
→ 觸發 Spec Agent (Claude Code / Cursor) 
→ 產生技術 Spec 到另一個 Repo
```

---

## 🔧 **工具推薦（小團隊輕量）**

| 需求 | 推薦工具 | 原因 |
|------|---------|------|
| **Coding Agent** | **Cursor** 或 **Claude Code** | 兩者都支援 Repo-wide context，Cursor 有 `.cursorrules`，Claude Code 有 `code` MCP server |
| **Knowledge Repo** | **GitHub + Markdown** | 最輕量，版本控制，Agent 友善 |
| **Templates** | **Markdown + YAML frontmatter** | 結構化但不重，Agent 容易解析 |
| **Workflow Automation** | **GitHub Actions** (free tier夠用) | 觸發下游 Spec 生成、通知 ClickUp |

---

### ⚠️ **實務上的坑（我踩過）**

#### **坑 1: Agent 產出太發散**
**解法：**
- Template 要有明確的 **"Acceptance Criteria"** section
- 在 prompt 裡加入 **"Maximum length: 500 words for each section"**
- 使用 **Structured Output（YAML/JSON frontmatter）** 強制格式

#### **坑 2: 上下文太多，Agent 反而混亂**
**解法：**
- 在 prompt 指定 **明確的 context files**：
  ```
  "Only reference /context/product/strategy-2024.md 
  and /context/users/persona-fleet-manager.md"
  ```
- 使用 **RAG 機制**（如果 context 超過 100 個文件）

#### **坑 3: PM 還是要 heavy review**
**現實：**
- **AI 不會取代 PM judgment**，它是 "思考夥伴 + 初稿機"
- 設計一個 **20% rule**：期望 Agent 節省 20-30% 時間，不是 80%
- **Value: 讓 PM 專注在策略判斷，而非格式整理**

---


**關鍵成功要素：**
1. **Context 品質 > Agent 能力**（垃圾進垃圾出）
2. **模板要有 opinionated structure**（不要只是空白文件）
3. **PM 要當 "Editor"，不是 "Writer"**（心態轉換）
